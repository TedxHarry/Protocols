# 🏆 Section 2.03 | Core Schema | “Group Schema”

---

## 📌 At a glance
The **Group Schema** defines how collections of users are represented in SCIM.  
Groups are used to **grant access, bundle permissions, and model roles** across applications.  

---

## 📖 What is the Group Schema?
The Group Schema provides a **standard structure** for defining groups and their memberships in SCIM.  
It ensures that identity providers and service providers can **consistently add, remove, and read** group relationships.

> **Notes**
- Defined in **RFC 7643 (SCIM Core Schema)**.  
- Endpoint: **`/Groups`**.  
- Core attributes: `displayName` and `members`.  

---

## 🔑 Key characteristics
- **Identity container** → Groups hold references to **User** objects.  
- **Access modeling** → Common way to assign app roles/permissions.  
- **Membership references** → `members[].value` stores **User IDs**, not names.  
- **Multi-valued** → `members` is a list; large groups require paging when fetching.  
- **Server-assigned `id`** → Uniquely identifies each group.  
- **Extensible** → Can include custom attributes if needed.  

---

## 🌍 Why it matters (and how it helps you later)
- Most SaaS apps rely on **group-based access control**.  
- Correct group modeling enables **least privilege** and clean **mover/leaver** flows.  
- Understanding the schema prevents **role explosion** and mapping errors when syncing with HR/IdP data.  

---

## 🛠️ Where it’s used (flows + impact)

### Membership lifecycle
```
IdP → SCIM /Groups → App
```
- Create group → `POST /Groups` → App role container appears.  
- Add user → `PATCH /Groups` `add members` → Access granted.  
- Remove user → `PATCH /Groups` `remove members` → Access revoked.  

Impact: Without SCIM, IT manually edits app-specific groups. With SCIM, **group joins/leaves** propagate automatically.  

---

## 🔗 How this links to other concepts
- [2.02 User Schema](2.02-user-schema.md) → Users are the members referenced by Groups.  
- [3.04 CRUD Operations](../3-protocol-operations/3.04-crud-operations.md) → Implements create/update/delete for Groups.  
- [3.05 Filtering](../3-protocol-operations/3.05-filtering.md) → Find groups or members efficiently.  

---

## ⚙️ Technical deep dive

### Attribute table (core Group schema)

| Attribute | Required | Type | Multi-valued | Notes |
|-----------|----------|------|---------------|-------|
| `id` | Yes | string | No | Server-assigned unique identifier. |
| `displayName` | Yes | string | No | Human-friendly group name. |
| `members` | No | complex | Yes | Array of membership objects referencing Users. |
| `meta` | Yes | complex | No | `created`, `lastModified`, `version`. |
| `schemas` | Yes | array | No | Must include Group schema URN. |

### Membership object shape
```json
{
  "value": "2819c223-7f76-453a-919d-413861904646",
  "display": "bjensen",
  "type": "User"
}
```
**Key points**:  
- `value` should be the **User `id`** from the SP, not `userName`.  
- `display` is optional; used for readability only.  
- `type` commonly "User" (some vendors allow "Group" for nested groups).  

### Example: Create group
```http
POST /Groups
Content-Type: application/scim+json

{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:Group"],
  "displayName": "Engineering"
}
```

### Example: Add two members to a group
```http
PATCH /Groups/c3d1d3f2
Content-Type: application/scim+json

{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:PatchOp"],
  "Operations": [{
    "op": "add",
    "path": "members",
    "value": [
      {"value": "2819c223-7f76-453a-919d-413861904646"},
      {"value": "d2f4acb1-8c44-4a7b-b0c2-192fbb12cd21"}
    ]
  }]
}
```

### Example: Remove one member
```http
PATCH /Groups/c3d1d3f2
Content-Type: application/scim+json

{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:PatchOp"],
  "Operations": [{
    "op": "remove",
    "path": "members[value eq "2819c223-7f76-453a-919d-413861904646"]"
  }]
}
```

---

## 🧩 Membership mapping tips

| Source (HR/IdP) | SCIM Group Schema | App Example |
|-----------------|-------------------|-------------|
| Department | `displayName` = "Engineering" | App role: `engineering_user` |
| Project team | `displayName` = "Project-Phoenix" | App ACL: `phoenix_editors` |
| Manager group | Add `members[].value` = user `id` | App permission: `manager_portal_access` |
| Access bundle | `displayName` = "ServiceNow-ITIL" | App role: `sn_itil` |

**Practical notes**:  
- Standardize **naming** to avoid duplicates across tenants.  
- Use **stable IDs** for membership references.  
- Consider **nested groups** only if the SP supports them.  

---

## 🏢 Real-world scenario
A tech company provisions GitHub teams via SCIM Groups.  

- IdP groups mirror internal roles: `Dev`, `QA`, `Ops`.  
- Adding a user to `Dev` group grants repo write access automatically.  
- Removing them from `Dev` removes write access, retaining read-only via another group.  

**Impact:** Consistent, auditable access aligned with role changes.  

---

## ❌ Common pitfalls
- Referencing `userName` instead of **User `id`** in `members.value`.  
- Forgetting to page through large groups → incomplete membership reads.  
- Assuming nested groups work everywhere.  
- Inconsistent group naming leading to duplicates.  
- Overloading groups with business attributes that belong in **User** records.  

---

## ⚠️ Risks & issues

| Risk | Impact | Mitigation |
|------|--------|------------|
| Large group operations | Timeouts, partial updates | Use paging; batch membership changes |
| Wrong membership references | Users miss access or get excess | Reference User `id`; validate before PATCH |
| Non-standard extensions | Breaks interoperability | Prefer core schema first |
| Orphaned groups | Stale access containers | Periodic cleanup based on usage |

**Real-world:** A team used `userName` in `members.value`. When usernames changed, memberships broke. Switching to **User IDs** fixed it.  

---

## 📝 Mini quiz
1. Which Group attribute is required by the SCIM core schema?  
   a) `members`  
   b) `displayName`  
   c) `externalId`  
   d) `owner`  

2. In a membership object, what should `members[].value` reference?  
   a) `userName`  
   b) `email`  
   c) User `id`  
   d) `display`  

3. Scenario: Group reads only return the first 100 members even though the group is larger. What should you implement?  
   a) Bulk endpoint  
   b) Paging on the GET request  
   c) Server-side filtering  
   d) Nested groups  

---

## 🔗 Navigation
👉 Back: [2.02 User Schema](2.02-user-schema.md)  
👉 Next: [2.04 Enterprise Extension](2.04-enterprise-extension.md)
