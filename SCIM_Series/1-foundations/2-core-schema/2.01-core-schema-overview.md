# 🏆 Section 2.01 | Core Schema | “Core Schema Overview”

---

## 📌 At a glance
The SCIM **core schema** defines the structure and rules for representing identity data.  
It provides the **standard attributes and object types** (Users and Groups) that all SCIM implementations must support.  

---

## 📖 What is Core Schema?
The SCIM core schema is the **blueprint for identity objects**. It ensures consistency in how identities are described and exchanged across systems.  
Every SCIM resource includes a `schemas` array referencing its applicable schema URNs.  

> **Notes**
- Defined in **RFC 7643**.  
- Two mandatory resource types: **User** and **Group**.  
- Supports **extensions**: enterprise attributes, custom fields.  

---

## 🔑 Key characteristics
- **Standardized attributes** → Common fields like `userName`, `emails`, `displayName`.  
- **Extensible model** → Enterprises can add custom schemas without breaking compatibility.  
- **Schemas array** → Every object explicitly lists the schema(s) it follows.  
- **Meta object** → Tracks `created`, `lastModified`, `version`.  
- **Interoperability** → All vendors must at least support the core schema.  
- **Validation** → Ensures resource payloads are correct and portable.  

---

## 🌍 Why it matters (and how it helps you later)
- Core schema guarantees **interoperability across IdPs and apps**.  
- Without it, each vendor would define attributes differently (e.g., “mail” vs “email”).  
- Learning the schema now prepares you for **attribute mapping, filtering, and custom extensions** later.  
- As an IAM engineer, you will spend significant time aligning app attributes with the SCIM schema.  

---

## 🛠️ Where it’s used (flows + impact)

### Example Flow
```
IdP (User Data) → SCIM Core Schema Mapping → SaaS Application
```

- User object → Created in SaaS apps via `/Users`.  
- Group object → Provisioned in apps via `/Groups`.  
- Attributes like `emails`, `groups`, and `userName` always exist thanks to schema enforcement.  

Impact: SCIM schema ensures **apps receive the right attributes in the right format**, reducing sync errors.  

---

## 🔗 How this links to other concepts
- [1.03 Core Objects](../1-foundations/1.03-core-objects.md) → Introduced Users and Groups conceptually; schema defines their structure.  
- [2.02 User Schema](2.02-user-schema.md) → Deep dive into required and optional attributes for Users.  
- [2.03 Group Schema](2.03-group-schema.md) → Details schema structure for Groups.  

---

## ⚙️ Technical deep dive

### Example: User schema excerpt
```json
{
  "id": "urn:ietf:params:scim:schemas:core:2.0:User",
  "name": "User",
  "description": "User Account",
  "attributes": [
    { "name": "userName", "type": "string", "required": true },
    { "name": "displayName", "type": "string", "required": false },
    { "name": "emails", "type": "complex", "multiValued": true }
  ]
}
```

### Example: Group schema excerpt
```json
{
  "id": "urn:ietf:params:scim:schemas:core:2.0:Group",
  "name": "Group",
  "description": "Group of Users",
  "attributes": [
    { "name": "displayName", "type": "string", "required": true },
    { "name": "members", "type": "complex", "multiValued": true }
  ]
}
```

**Key points**:  
- `userName` → required in every User object.  
- `displayName` → required in every Group object.  
- `schemas` URN must always be present.  

---

## 🏢 Real-world scenario
A company integrates Okta with Salesforce via SCIM.  

- Without schema alignment: Salesforce expected `email`, while IdP sent `mail`. Provisioning failed.  
- With SCIM core schema: Attribute mapped to `emails.value`. Provisioning succeeded.  

**Impact:** Fewer integration errors, faster onboarding, audit-ready attributes.  

---

## ❌ Common pitfalls
- Forgetting the `schemas` array → request rejected.  
- Mismatched attribute names (`mail` vs `emails`).  
- Ignoring `meta` fields → makes troubleshooting harder.  
- Overloading custom attributes → breaks interoperability.  

---

## ⚠️ Risks & issues

| Risk | Impact | Mitigation |
|------|--------|------------|
| Vendor schema drift | Incompatible provisioning | Map carefully and test attributes |
| Missing required fields | Request rejections | Validate before sending |
| Overuse of custom schema | Breaks portability across vendors | Stick to enterprise extension where possible |
| Not handling `meta` | Lost change-tracking | Always include `meta` where expected |

**Real-world:** A provisioning system broke because vendor used `mail` instead of SCIM-standard `emails`, causing thousands of failed account creations.  

---

## 📝 Mini quiz
1. Which RFC defines the SCIM core schema?  
   a) RFC 7644  
   b) RFC 7643  
   c) RFC 4511  
   d) RFC 5280  

2. Which attribute is **required** in every User object?  
   a) `displayName`  
   b) `userName`  
   c) `externalId`  
   d) `meta.version`  

3. Scenario: An IdP sends `mail` while the SP expects `emails.value`. What’s the issue?  
   a) Schema drift  
   b) Authentication failure  
   c) Authorization mismatch  
   d) Wrong meta object  

---

## 🔗 Navigation
👉 Back: [1.06 SCIM in IAM](../1-foundations/1.06-scim-in-iam.md)  
👉 Next: [2.02 User Schema](2.02-user-schema.md)
