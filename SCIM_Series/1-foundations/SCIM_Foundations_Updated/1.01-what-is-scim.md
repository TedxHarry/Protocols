# ğŸ† Section 1.01 | Foundations | **"What is SCIM?"**

## ğŸ“Œ At a glance  
SCIM is an open standard that lets identity systems and apps create, update, and remove users and groups in a consistent way. It cuts integration cost and closes security gaps by automating provisioning and deprovisioning.

---

## ğŸ“– What is SCIM?  
SCIM is an IETF standard that defines a common schema and a RESTful API for identity lifecycle actions across systems. Identity providers (Okta, Entra ID, SailPoint) call service providers (Slack, Zoom, GitHub) using JSON requests to keep accounts in sync during joiner, mover, and leaver events.

**ğŸ”„ One-glance flow**
```text
HR System â†’ IdP (Okta / Entra / SailPoint) â†’ SCIM API â†’ SaaS App
   Hire        create/update user/event        POST/PUT/PATCH      account created/updated
```

> **Note (worth keeping):** SCIM is defined by **RFC 7643** (Schema) and **RFC 7644** (Protocol). Vendors often vary on details such as **PATCH** behavior, supported filters, and custom attributes, so you should always test those parts early.

---

## â— Problem before SCIM  
- Every app had its own user API or none at all, so teams built and maintained many custom connectors.  
- Onboarding and offboarding were slow and error-prone.  
- Missed deprovisioning left orphaned accounts and audit findings.

---

## ğŸ”‘ Key characteristics  
- **REST + JSON**, easy to implement and debug.  
- **Core objects: Users and Groups**, a shared vocabulary across platforms.  
- **Extensible**, supports enterprise and custom attributes without breaking the model.  
- **Lifecycle focus**, built for create, update, deactivate, and delete.  
- **Interoperable**, reduces bespoke code and speeds up integrations.

---

## ğŸŒ Why it matters (and how it helps you later)  
- Improves security by removing access on time and reducing shadow accounts.  
- Lowers integration cost by avoiding one-off connectors.  
- Gives you a foundation to read SCIM payloads, debug provisioning jobs, and answer interview questions about PATCH vs PUT, filters, and schema mapping.  
- Sets you up for upcoming topics: User schema, Group schema, CRUD, filtering, and troubleshooting.

---


## ğŸ› ï¸ Where itâ€™s used (flows + impact)
- **Joiner** â†’ HR adds employee â†’ IdP **POST /Users** â†’ app account **created automatically**, no IT tickets required.
- **Mover** â†’ Role/department change â†’ IdP **PATCH /Users** or **PATCH /Groups** â†’ roles, entitlements, and memberships **updated instantly**.
- **Leaver** â†’ Exit event â†’ IdP **DELETE /Users** or `active=false` â†’ accounts **disabled across apps the same day**, no orphaned access.

ğŸ‘‰ Without SCIM: weeks of manual tickets and scripts. With SCIM: minutes, fully auditable.

## ğŸ”— How this links to other concepts (learning bridges)
- **Core Objects (1.03)** â†’ Lifecycle acts on Users & Groups. Without these, lifecycle has no targets.
- **CRUD Operations (3.04)** â†’ JML maps directly to POST, PATCH/PUT, and DELETE or soft disable.
- **Failures (4.03)** â†’ Shows what happens when lifecycle fails (e.g., orphaned accounts left active).
## ğŸ”— Navigation  
ğŸ‘‰ **Back:** [README](../1-foundations/README.md)  
ğŸ‘‰ **Next:** [1.02 SCIM Architecture](../1-foundations/1.02-scim-architecture.md)  


## âš ï¸ Risks & issues
| Risk | Impact | Mitigation |
|------|--------|------------|
| Mis-mapped attributes | Inconsistent accounts | Validate schema mapping in pilots |
| Weak deprovisioning | Orphaned accounts remain active | Test disable/delete paths in each app |
| Partial vendor support | Missing PATCH or filters | Check `/ServiceProviderConfig`, plan workarounds |
| Protocol confusion | Wrong tool for the job | Train teams on SCIM vs SSO protocols |

Real-world: A company kept 200+ Slack users active months after exit because SCIM wasnâ€™t connected. Audit flagged this as high-risk.
