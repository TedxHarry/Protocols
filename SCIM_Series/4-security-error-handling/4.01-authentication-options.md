# 🏆 Section 4.01 | Security & Error Handling | “Authentication Options”

---

## 📌 At a glance
SCIM endpoints must be protected to prevent unauthorized provisioning.  
Authentication ensures only **trusted clients** (like IdPs) can create, update, or delete resources in a SCIM server.  

---

## 📖 What are SCIM Authentication Options?
SCIM itself doesn’t mandate a single authentication mechanism.  
Instead, it allows **multiple options** that vendors can implement to secure SCIM requests.

> **Notes**
- Defined in **RFC 7644, Section 2**.  
- Common methods: OAuth2 Bearer Tokens, API Keys, Mutual TLS (MTLS).  
- Authentication is applied at the **HTTP layer**, not inside SCIM JSON.  

---

## 🔑 Key characteristics
- **OAuth2 Bearer Tokens** → Most common, short-lived tokens for secure access.  
- **API Keys** → Simple static secret, but weaker security.  
- **Mutual TLS (MTLS)** → Certificate-based trust; stronger but harder to manage.  
- **Basic Auth** → Sometimes supported, but deprecated due to weak security.  
- **Per-request validation** → Every SCIM call must be authenticated individually.  
- **Separation of duties** → AuthN handled at transport layer, SCIM handles identity payloads.  

---

## 🌍 Why it matters (and how it helps you later)
- Without authentication, SCIM endpoints become a **massive attack surface**.  
- Choosing the right method balances **security vs operational overhead**.  
- As an IAM engineer, you’ll configure integrations to authenticate SCIM requests.  
- Later, this ties directly into **error handling** when auth fails (e.g., 401/403 errors).  

---

## 🛠️ Where it’s used (flows + impact)

### Example Flow
```
IdP → (OAuth2 Bearer Token) → SCIM /Users → SaaS App
```
- Joiner → `POST /Users` authenticated with token.  
- Mover → `PATCH /Users` validated per request.  
- Leaver → `PATCH active:false` rejected if token expired.  

Impact: Authentication protects against **rogue provisioning and data leaks**.  

---

## 🔗 How this links to other concepts
- [3.08 Bulk Operations](../3-protocol-operations/3.08-bulk-operations.md) → Every bulk request must be authenticated.  
- [4.02 Error Codes](4.02-error-codes.md) → Auth failures surface as 401/403.  
- [5.01 Using Postman](../5-real-world-implementation/5.01-using-postman.md) → You’ll practice setting authentication headers.  

---

## ⚙️ Technical deep dive

### Example: OAuth2 Bearer Token
```http
GET /Users
Authorization: Bearer eyJhbGciOi...
```

### Example: API Key
```http
GET /Users
Authorization: ApiKey X9sd91kdlsm2
```

### Example: Mutual TLS
- Client presents certificate when connecting.  
- Server verifies client certificate against trust store.  

**Key points**:  
- OAuth2 is **best practice** for most vendors.  
- API keys still common but less secure (static secret).  
- MTLS used in high-security or regulated environments.  

---

## 🏢 Real-world scenario
A healthcare SaaS app requires SCIM with MTLS.  

- Okta integration configured with client certificate.  
- Every SCIM call validated at the TLS handshake.  
- Compliance teams approved it for HIPAA because static keys were not acceptable.  

**Impact:** Stronger assurance that only trusted IdPs could provision accounts.  

---

## ❌ Common pitfalls
- Using static API keys in production without rotation.  
- Forgetting to refresh OAuth2 tokens → sync jobs fail.  
- Relying on Basic Auth → deprecated and insecure.  
- Not securing tokens at rest → risk of leaks.  
- Misconfigured trust store in MTLS → integration blocked.  

---

## ⚠️ Risks & issues

| Risk | Impact | Mitigation |
|------|--------|------------|
| Token expiration | Provisioning stops | Implement token refresh logic |
| API key leak | Unauthorized access | Rotate keys; restrict by IP |
| MTLS misconfig | No connectivity | Test certificates before production |
| Basic Auth use | Weak security | Replace with OAuth2/MTLS |

**Real-world:** A team left an API key in source code repo. Attackers exploited it to create rogue accounts. Moving to OAuth2 with short-lived tokens fixed the issue.  

---

## 📝 Mini quiz
1. Which authentication option is most secure but harder to manage?  
   a) API Key  
   b) Basic Auth  
   c) OAuth2 Bearer Token  
   d) Mutual TLS  

2. Which authentication method is deprecated and discouraged for SCIM?  
   a) Basic Auth  
   b) API Key  
   c) OAuth2 Bearer Token  
   d) MTLS  

3. Scenario: Your SCIM integration stops working overnight. Logs show 401 Unauthorized. What’s the most likely issue?  
   a) Wrong schema URN  
   b) Expired OAuth2 token  
   c) PATCH not supported  
   d) Endpoint renamed  

---

## 🔗 Navigation
👉 Back: [3.08 Bulk Operations](../3-protocol-operations/3.08-bulk-operations.md)  
👉 Next: [4.02 Error Codes](4.02-error-codes.md)  

➡️ Next, we’ll explore **Error Codes (4.02)** to understand SCIM failure responses and how to act on them.
