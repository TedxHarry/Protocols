# 🏆 Section 4.03 | Security & Error Handling | “Common Failures”

---

## 📌 At a glance
Common SCIM failures usually come from **capability mismatches, schema mapping errors, and transport issues**.  
Knowing the patterns will help you diagnose quickly and keep provisioning reliable and auditable.  

---

## 📖 What are Common Failures?
These are **recurring failure modes** seen across SCIM integrations in the field.  
They cluster around **auth problems, unsupported features, bad mappings, filtering gaps, and pagination mistakes**.

> **Notes**
- Grounded in **RFC 7643 and RFC 7644** behaviors.  
- Many issues are visible via **`/ServiceProviderConfig`** and **`/Schemas`**.  
- Always capture and parse the **SCIM error body** for `scimType`, `detail`, and `status`.  

---

## ❗ Problem before understanding failures
- Teams shipped integrations that worked in staging but **collapsed at scale**.  
- Silent mismatches caused **orphaned accounts and audit findings**.  
- Without clear patterns, engineers chased random bugs instead of **systematically testing** SCIM capabilities.  

---

## 🔑 Key characteristics
- **Repeatable patterns** → Same families of issues appear across vendors.  
- **Discoverable upfront** → `/ServiceProviderConfig` exposes limits like missing PATCH or Bulk.  
- **Schema-driven** → Attribute names, case, and multi-valued rules drive many errors.  
- **Transport coupling** → AuthN and rate limits surface as 401, 403, 429.  
- **Scale sensitive** → Pagination, sorting, and filters must be correct for large directories.  
- **Recoverable** → Good retries and idempotency make failures safe.  

---

## 🌍 Why it matters (and how it helps you later)
- Shortens troubleshooting from days to **minutes** by matching symptoms to patterns.  
- Prevents **security drift** by ensuring deprovisioning does not fail silently.  
- Builds muscle memory for **post-incident reviews** and **audit evidence**.  
- Prepares you for advanced topics like **vendor limitations** and **bulk safety**.  

---

## 🛠️ Where it’s used (flows + impact)

### Joiner
```
HR → IdP → POST /Users → App
```
Failure patterns: 400 invalidValue, 409 uniqueness conflict, 401 Unauthorized.  
Impact: Delayed onboarding, duplicate or missing accounts.

### Mover
```
HR update → IdP → PATCH /Users → App
```
Failure patterns: PATCH not supported, mutability violation, wrong attribute path.  
Impact: Privilege creep from stale attributes or groups.

### Leaver
```
Termination → IdP → PATCH active:false → App
```
Failure patterns: Token expired, network timeouts, server 500, delete instead of disable.  
Impact: Orphaned accounts and audit gaps.  

---

## 🔗 How this links to other concepts
- [4.01 Authentication Options](4.01-authentication-options.md) → Many failures are simple auth misconfigurations.  
- [4.02 Error Codes](4.02-error-codes.md) → Decode `status` and `scimType` to pinpoint root cause.  
- [5.03 Troubleshooting](../5-real-world-implementation/5.03-troubleshooting.md) → Applies these patterns step by step with decision trees.  

---

## ⚙️ Technical deep dive

### 1) Missing required attribute on create
**Symptom**: User create fails.  
**Example response:**
```http
HTTP/1.1 400 Bad Request
Content-Type: application/scim+json

{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "scimType": "invalidValue",
  "detail": "Missing required attribute userName",
  "status": "400"
}
```
**Fix**: Map required fields. Validate payloads before send.

### 2) PATCH not supported
**Symptom**: Movers fail.  
**Check**: `/ServiceProviderConfig` shows `"patch": { "supported": false }`.  
**Workaround**: Use `PUT` with full resource where safe or vendor-specific update mechanism.

### 3) Duplicate resource conflict
**Symptom**: 409 on create.  
**Response:**
```http
HTTP/1.1 409 Conflict
Content-Type: application/scim+json

{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "scimType": "uniqueness",
  "detail": "Duplicate userName",
  "status": "409"
}
```
**Fix**: Correlate using `externalId`. Decide on update vs skip.

### 4) Unsupported filter or bad query
**Symptom**: GET returns 400 or empty.  
**Example response:**
```http
HTTP/1.1 400 Bad Request
Content-Type: application/scim+json

{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "scimType": "invalidFilter",
  "detail": "Filter operator not supported",
  "status": "400"
}
```
**Fix**: Fall back to supported operators. URL-encode filters. Verify attribute names via `/Schemas`.

### 5) Pagination mistakes at scale
**Symptom**: Missing users after large reads.  
**Cause**: 0-based `startIndex`, no `sortBy`, ignoring `itemsPerPage`.  
**Fix**: Use 1-based `startIndex`. Add `sortBy`. Iterate until `totalResults` reached.

### 6) Group membership updates fail
**Symptom**: `PATCH /Groups` returns 400.  
**Cause**: Using `userName` instead of User `id` in `members.value`.  
**Fix**: Reference the SCIM server User `id` only.

### 7) Auth and rate limit failures
**Symptoms**: 401 Unauthorized, 403 Forbidden, 429 Too Many Requests.  
**Fix**: Refresh tokens, verify scopes, implement exponential backoff and jitter.

---

## 🏢 Real-world scenario
A retailer’s deprovision flow silently failed due to expired OAuth token.  
Termination events continued in HR, but `PATCH active:false` calls returned 401 and were not retried.  
Two months later, auditors found hundreds of active SaaS accounts for former employees.  
**Fix**: Token refresh with retries and alerting on any 401 or 403 during leaver runs.  

---

## ❌ Common pitfalls
- Skipping `/ServiceProviderConfig` discovery and assuming PATCH or Bulk exists.  
- Treating `externalId` as optional and causing 409 conflicts.  
- Using `DELETE` for leavers and losing audit evidence.  
- Not URL-encoding filters with spaces and quotes.  
- Forgetting SCIM is 1-based pagination.  

---

## ⚠️ Risks & issues

| Risk | Impact | Mitigation |
|------|--------|------------|
| Silent auth failures | Orphaned accounts | Monitor 401 and 403, auto refresh tokens |
| Unsupported features | Broken movers or bulk loads | Read `/ServiceProviderConfig` and adapt flows |
| Schema mismatches | Bad data or request rejection | Validate against `/Schemas`, pilot test mappings |
| Paging errors at scale | Missing or duplicated users | Use `startIndex` 1-based, set `sortBy`, loop to `totalResults` |

**Real-world:** A university used `userName` for group membership references. Name changes broke access. Switching to User `id` resolved it.  

---

## 📝 Mini quiz
1. Your `PATCH /Users` calls fail with 400 and `scimType: mutability`. What is the likely cause?  
   a) Missing token  
   b) Read-only attribute was changed  
   c) Duplicate externalId  
   d) Invalid pagination index  

2. You see 409 on `POST /Users` for a person who already exists. What should you implement?  
   a) Hard delete then recreate  
   b) Use `externalId` correlation and update logic  
   c) Switch to SOAP API  
   d) Add more filters

3. A sync returns only 1000 users per page despite requesting 5000. What should you do?  
   a) Fail the job  
   b) Respect `itemsPerPage` and iterate pages  
   c) Increase timeout and retry once  
   d) Use DELETE to clear results

---

## 🔗 Navigation
👉 Back: [4.02 Error Codes](4.02-error-codes.md)  
👉 Next: [4.04 Vendor Limitations](4.04-vendor-limitations.md)  

➡️ Next, we’ll explore **Vendor Limitations (4.04)** to catalog common deviations in PATCH semantics, filtering, groups, and delete behavior.
