# 🏆 Section 5.02 | Real-world Implementation | “Building SCIM Server”

---

## 📌 At a glance
A SCIM server is the **provider side** of the protocol.  
It exposes SCIM endpoints (`/Users`, `/Groups`, etc.) that clients (like Azure AD, Okta, SailPoint) call to manage identities.  

---

## 📖 What is a SCIM Server?
A SCIM server is an **API implementation** that follows RFC 7643/7644 to enable automated provisioning and deprovisioning.  
It accepts HTTP requests and translates them into **create, read, update, delete** actions against the target system.

> **Notes**
- Defines endpoints: `/Users`, `/Groups`, `/Schemas`, `/ServiceProviderConfig`.  
- Must follow **SCIM schema** and support JSON payloads.  
- Server enforces **business logic, validations, and persistence**.  
- Vendor-specific extensions may be required.  

---

## ❗ Problem before SCIM servers
- Manual user creation in apps was **slow and error-prone**.  
- No consistent way to sync HR systems with SaaS.  
- Deprovisioning often missed, leading to **orphaned accounts**.  
- Every vendor had proprietary APIs → high integration cost.  

---

## 🔑 Key characteristics
- **Standards-based** → Follows RFC 7643/7644.  
- **Extensible** → Supports custom schemas for enterprise needs.  
- **Interoperable** → Works with IdPs (Okta, Azure AD, Ping, SailPoint).  
- **CRUD + search** → Core functions for lifecycle management.  
- **Secure** → Requires auth (OAuth2, MTLS).  
- **Auditable** → Returns consistent error codes for compliance evidence.  

---

## 🌍 Why it matters (and how it helps you later)
- As an IAM engineer, you’ll often **integrate new apps by building or testing SCIM servers**.  
- Knowing how servers work helps debug **why provisioning fails**.  
- Essential for vendors offering SaaS → SCIM is now table stakes.  
- Deepens understanding of **Joiner/Mover/Leaver automation**.  

---

## 🛠️ Where it’s used (flows + impact)

### Example Joiner Flow
```
HR → IdP → SCIM Server (/Users) → Application DB
```
- IdP calls `POST /Users`.  
- SCIM server validates schema and creates record in DB.  
- Response returns user `id`.  

Impact: New employee account created instantly and consistently.  

### Example Leaver Flow
```
HR → IdP → SCIM Server (/Users/{id}) PATCH active:false → Application DB
```
- User disabled in target app.  
- Preserves audit evidence.  

---

## 🔗 How this links to other concepts
- [5.01 Using Postman](5.01-using-postman.md) → Use Postman to test SCIM server endpoints.  
- [5.03 Troubleshooting](5.03-troubleshooting.md) → Server logs are critical in diagnosing failures.  
- [2.02 User Schema](../2-core-schema/2.02-user-schema.md) → Servers must implement schema validation.  

---

## ⚙️ Technical deep dive

### Minimal SCIM server outline (pseudo-code)
```python
# Example SCIM server endpoint (simplified)
@app.route('/scim/v2/Users', methods=['POST'])
def create_user():
    payload = request.json
    if 'userName' not in payload:
        return error_response("Missing required attribute userName", 400, "invalidValue")
    user_id = db.create(payload)
    return {
        "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
        "id": user_id,
        "userName": payload["userName"]
    }, 201
```

**Key fields**:  
- `schemas` → defines SCIM object type.  
- `id` → unique identifier.  
- Error handling required per RFC.  

### Example: ServiceProviderConfig response
```json
{
  "schemas":["urn:ietf:params:scim:schemas:core:2.0:ServiceProviderConfig"],
  "patch":{"supported":true},
  "bulk":{"supported":false},
  "filter":{"supported":true, "maxResults":200},
  "sort":{"supported":true}
}
```
**Use**: Advertises which features the server supports.  

---

## 🏢 Real-world scenario
A SaaS vendor built a SCIM server to onboard enterprise customers.  

- Before: Customers wrote custom scripts to sync users.  
- After: Customers pointed Okta to `/scim/v2/Users` and provisioning worked out-of-the-box.  
- **Impact:** Adoption improved, support tickets dropped, compliance easier.  

---

## ❌ Common pitfalls
- Not validating schema → Bad data stored.  
- Returning wrong HTTP codes (e.g., 200 instead of 201).  
- Skipping error payload → Clients can’t debug.  
- Ignoring PATCH or filters when required.  
- Not documenting vendor-specific extensions.  

---

## ⚠️ Risks & issues

| Risk | Impact | Mitigation |
|------|--------|------------|
| Missing schema validation | Bad or non-compliant data | Enforce schema rules strictly |
| Wrong status codes | Client misbehavior | Follow RFC for 200/201/204/400/409/500 |
| No auth enforcement | Security gaps | Require OAuth2 or MTLS |
| No logging | Harder debugging & audit failures | Centralized logging of SCIM requests |

**Real-world:** An app accepted `DELETE /Users` but silently disabled accounts. Auditors flagged mismatch between logs and intent. Explicit `PATCH active:false` resolved compliance risk.  

---

## 📝 Mini quiz
1. Which SCIM endpoint is required for any compliant SCIM server?  
   a) `/Bulk`  
   b) `/Users`  
   c) `/ResourceTypes`  
   d) `/Password`  

2. Scenario: Your SCIM server allows user creation but fails to enforce schema. What’s the risk?  
   a) Faster performance  
   b) Non-compliant or corrupt data in DB  
   c) Reduced provisioning errors  
   d) Easier vendor adoption  

3. What does `/ServiceProviderConfig` advertise?  
   a) Current users  
   b) Vendor capabilities (PATCH, Bulk, filter support)  
   c) Group memberships  
   d) Custom schema extensions  

---

## 🔗 Navigation
👉 Back: [5.01 Using Postman](5.01-using-postman.md)  
👉 Next: [5.03 Troubleshooting](5.03-troubleshooting.md)  

➡️ Next, we’ll explore **Troubleshooting (5.03)** with decision trees for diagnosing SCIM provisioning issues.
