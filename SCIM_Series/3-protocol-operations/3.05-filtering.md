# 🏆 Section 3.05 | Protocol Operations | “Filtering”

---

## 📌 At a glance
SCIM filtering lets clients **search and target resources precisely** using a standard query language.  
It reduces data transfer, speeds up syncs, and makes provisioning logic reliable across vendors.  

---

## 📖 What is SCIM Filtering?
Filtering is the **query mechanism** defined by the SCIM protocol for selecting resources that match conditions.  
You attach a `filter` parameter to `GET` requests to `/Users` or `/Groups` to find the exact records you need.

> **Notes**
- Defined in **RFC 7644, Section 3.4.2**.  
- Common operators: `eq`, `ne`, `co`, `sw`, `ew`, `gt`, `ge`, `lt`, `le`, logical `and`/`or`, grouping with parentheses.  
- Case sensitivity is vendor dependent - always test.  

---

## ❗ Problem before SCIM Filtering
- Vendors invented **proprietary query syntaxes**.  
- Integrations downloaded everything, then filtered on the client - slow and wasteful.  
- Inconsistent search semantics created bugs in joiner/mover/leaver logic.  
- SCIM filtering delivered a **portable, predictable** query language.  

---

## 🔑 Key characteristics
- **Resource targeting** → Find users or groups by attribute conditions.  
- **Logical composition** → Combine multiple criteria with `and` or `or`.  
- **Nested paths** → Query into complex or multi-valued attributes (e.g., `emails[value co "example.com"]`).  
- **Server-side efficiency** → Reduces payload size and processing on clients.  
- **Standards-based** → Moves custom search logic into a portable protocol feature.  
- **Capability variance** → Some vendors only support a subset - verify first.  

---

## 🌍 Why it matters (and how it helps you later)
- Filtering is the backbone of **incremental sync**, **conflict detection**, and **access reviews**.  
- It lets you query only what you need - reduces API calls and speeds up jobs.  
- You will rely on filters for **mover logic** (e.g., find all users in a department) and **leaver checks** (e.g., verify active status across apps).  
- Mastery here pays off when you implement **pagination, attribute selection, and bulk** in later topics.  

---

## 🛠️ Where it’s used (flows + impact)

### Common flows
```
IdP → GET /Users?filter=... → SCIM Server
IdP → GET /Groups?filter=... → SCIM Server
```
- **Joiner checks**: Ensure user does not exist before create.  
- **Mover updates**: Find users by department or title for bulk changes.  
- **Leaver verification**: Confirm `active eq false` across apps.  

Impact: Server-side filtering reduces **bandwidth and latency**, and avoids stale client-side caches.  

---

## 🔗 How this links to other concepts
- [3.04 CRUD Operations](3.04-crud-operations.md) → Filtering enhances the **Read** part of CRUD.  
- [3.06 Pagination & Sorting](3.06-pagination-sorting.md) → Combine with filters to traverse large result sets safely.  
- [3.07 Attribute Selection](3.07-attribute-selection.md) → Fetch only the attributes you need after filtering.  

---

## ⚙️ Technical deep dive

### Supported operators (typical)
- Comparison: `eq`, `ne`, `gt`, `ge`, `lt`, `le`  
- String: `co` (contains), `sw` (starts with), `ew` (ends with)  
- Logical: `and`, `or`  
- Grouping: parentheses `( ... )`  
- Presence checks: some vendors allow `pr` (present) - verify via `/ServiceProviderConfig` or docs

### Six practical filter examples

1) **Find by userName**
```http
GET /Users?filter=userName eq "bjensen"
```

2) **Find by email domain**
```http
GET /Users?filter=emails[value co "example.com"]
```

3) **Find active users in a department**
```http
GET /Users?filter=active eq true and department eq "Engineering"
```

4) **Case and partial match on display name**
```http
GET /Users?filter=displayName sw "Barb"
```

5) **Find group by name**
```http
GET /Groups?filter=displayName eq "Engineering"
```

6) **Compound condition with precedence**
```http
GET /Users?filter=(department eq "Sales" or department eq "Marketing") and active eq true
```

### Example response (truncated)
```json
{
  "totalResults": 1,
  "startIndex": 1,
  "itemsPerPage": 1,
  "Resources": [
    {
      "id": "2819c223-7f76-453a-919d-413861904646",
      "userName": "bjensen",
      "displayName": "Barbara Jensen",
      "emails": [{ "value": "bjensen@example.com", "primary": true }],
      "active": true,
      "meta": { "resourceType": "User" }
    }
  ],
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"]
}
```
**Key fields**:  
- `totalResults` - size of the full result set.  
- `itemsPerPage` and `startIndex` - for pagination.  
- `Resources[]` - array of matching objects.  
- `schemas` - always `ListResponse` for list results.  

---

## 🏢 Real-world scenario
A company needs to locate all active contractors in the “Field Ops” division to adjust license counts.  

- Filter used: `GET /Users?filter=active eq true and division eq "Field Ops"`  
- Combined with pagination to process 20,000 results safely.  
- Attribute selection returned only `id`, `userName`, `division` to cut payload size.  

**Impact:** Saved hours of API time per run and prevented license overages.  

---

## ❌ Common pitfalls
- Assuming all operators are supported - many vendors only implement a subset.  
- Forgetting to URL-encode filter strings, especially quotes and spaces.  
- Using client-side filters after fetching everything - slow and costly.  
- Relying on case-insensitive matching when the vendor is case-sensitive.  
- Not validating attribute names against `/Schemas` first.  

---

## ⚠️ Risks & issues

| Risk | Impact | Mitigation |
|------|--------|------------|
| Unsupported operators | Filter rejected or misapplied | Validate via `/ServiceProviderConfig`; fall back to supported ops |
| Large result sets | Timeouts, partial reads | Combine filters with pagination and sorting |
| Case sensitivity mismatch | False negatives | Test filter behavior and normalize casing |
| Attribute name mismatches | Empty results | Align with `/Schemas` attribute names |

**Real-world:** An integration shipped with `co` filters against a vendor that only supported `eq` and `sw`. Queries silently returned empty sets. Adding capability checks fixed it.  

---

## 📝 Mini quiz
1. Which operator checks for substring matches in SCIM?  
   a) `sw`  
   b) `co`  
   c) `eq`  
   d) `gt`  

2. What response schema is used for list results returned by a filtered GET?  
   a) `Error`  
   b) `ListResponse`  
   c) `PatchOp`  
   d) `BulkResponse`  

3. Scenario: Your filter `emails[value co "acme.com"] and active eq true` returns nothing in production but works in staging. What is the first thing to verify?  
   a) Case sensitivity of `emails.value`  
   b) Whether `co` is supported in production vendor config  
   c) If `active` is a string instead of boolean  
   d) If `emails` is multi-valued in production

---

## 🔗 Navigation
👉 Back: [3.04 CRUD Operations](3.04-crud-operations.md)  
👉 Next: [3.06 Pagination & Sorting](3.06-pagination-sorting.md)  

➡️ Next, we’ll explore **Pagination & Sorting (3.06)** to control list sizes, ordering, and stable traversal of large datasets.
