# 🏆 Section 3.06 | Protocol Operations | “Pagination & Sorting”

---

## 📌 At a glance
Pagination and sorting in SCIM control **how many results you get, where you start, and in what order**.  
They make large directory queries reliable, performant, and predictable.  

---

## 📖 What are Pagination & Sorting?
SCIM defines **query parameters** to page through large result sets and to order results consistently.  
You’ll use these on list endpoints like `/Users` and `/Groups` in combination with filtering.

> **Notes**
- Defined in **RFC 7644, Section 3.4.2**.  
- Pagination params: `startIndex` (1-based), `count`.  
- Sorting params: `sortBy` (attribute), `sortOrder` (`ascending` or `descending`).  

---

## 🔑 Key characteristics
- **1-based index** → `startIndex=1` is the first item, not 0.  
- **Server limits** → Actual page size may be capped by the SCIM server.  
- **Stable order** → Provide `sortBy` to avoid non-deterministic pages.  
- **Combines with filter** → Page only the matches you care about.  
- **List response schema** → Always returns `totalResults`, `itemsPerPage`, `startIndex`, `Resources[]`.  
- **Performance lever** → Reduces bandwidth and timeout risk on large directories.  

---

## 🌍 Why it matters (and how it helps you later)
- Large directories can have **hundreds of thousands** of users and groups.  
- Proper paging and sorting prevent **timeouts, rate limit bursts, and duplicates/omissions** during syncs.  
- Mastery here unlocks robust **incremental sync** and **access recertification** flows.  

---

## 🛠️ Where it’s used (flows + impact)

### Common flows
```
IdP → GET /Users?filter=...&startIndex=1&count=200&sortBy=userName&sortOrder=ascending
IdP → GET /Groups?startIndex=201&count=200
```
Impact: Deterministic traversals, consistent delta processing, and lower API cost.  

---

## 🔗 How this links to other concepts
- [3.05 Filtering](3.05-filtering.md) → Page only the subset you filtered for.  
- [3.07 Attribute Selection](3.07-attribute-selection.md) → Cut payload size further by selecting only needed fields.  
- [3.08 Bulk Operations](3.08-bulk-operations.md) → Use paging to stage safe bulk changes.  

---

## ⚙️ Technical deep dive

### Example: First page of active Engineering users, sorted by userName
```http
GET /Users?filter=active eq true and department eq "Engineering"&startIndex=1&count=100&sortBy=userName&sortOrder=ascending
```
**What to expect in response**
```json
{
  "totalResults": 8240,
  "startIndex": 1,
  "itemsPerPage": 100,
  "Resources": [ /* first 100 users */ ],
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"]
}
```

### Example: Next page
```http
GET /Users?filter=active eq true and department eq "Engineering"&startIndex=101&count=100&sortBy=userName&sortOrder=ascending
```

### Example: Sort groups by displayName descending
```http
GET /Groups?startIndex=1&count=50&sortBy=displayName&sortOrder=descending
```

**Key fields in ListResponse**
- `totalResults` → Count of all matches across all pages.  
- `itemsPerPage` → Actual number returned (may be lower than requested `count`).  
- `startIndex` → 1-based index of first returned item.  
- `Resources[]` → The items for this page.  

### Stability tips
- Always set **`sortBy`** for deterministic paging (e.g., `userName`, `id`, or `meta.lastModified`).  
- If data mutates rapidly, consider a **time-windowed approach** using `meta.lastModified ge "..."` with fixed windows.  
- Record **last seen `id` or `meta.lastModified`** to resume safely after failures.  

---

## 🏢 Real-world scenario
A retailer needs a nightly sync of 120k users into a data warehouse.  

- They use `count=1000` with `sortBy=meta.lastModified` and filter by last 24 hours.  
- Each run persists the **last processed timestamp** and resumes from there if interrupted.  
- Payload size is reduced by combining attribute selection to fetch only `id`, `userName`, and `meta.lastModified`.  

**Impact:** Sync duration dropped from 3 hours to **under 25 minutes** with zero duplicates.  

---

## ❌ Common pitfalls
- Treating `startIndex` as 0-based → off-by-one errors and missed records.  
- Not setting `sortBy` → non-deterministic pages when data changes mid-run.  
- Assuming `count` will be honored → servers can cap `itemsPerPage`.  
- Forgetting to combine paging with **filters** and **attribute selection** → bloated payloads.  
- Ignoring `totalResults` → no sense of completion or gap detection.  

---

## ⚠️ Risks & issues

| Risk | Impact | Mitigation |
|------|--------|------------|
| Mid-run data churn | Duplicates or misses across pages | Use `sortBy` + time windows; checkpoint last processed |
| Server-imposed page caps | Incomplete reads if not looped | Respect `itemsPerPage`; iterate until collected `totalResults` |
| Off-by-one paging | Missed or repeated records | Remember SCIM is 1-based indexing |
| Large payloads | Timeouts, rate limit hits | Reduce `count`; add attribute selection; backoff & retry |

**Real-world:** A sync missed hundreds of users because the team used `startIndex=0`. Switching to 1-based indexing fixed the gap.  

---

## 📝 Mini quiz
1. What is the **index base** for SCIM pagination?  
   a) 0-based  
   b) 1-based  
   c) Server-dependent  
   d) Client-configurable  

2. Which parameters control sorting in SCIM list operations?  
   a) `sortBy` and `sortOrder`  
   b) `orderBy` and `direction`  
   c) `rankBy` and `rankOrder`  
   d) `groupBy` and `order`  

3. Scenario: Your nightly job requests `count=5000` but receives only 1000 items per page. What should you do?  
   a) Fail the job  
   b) Assume the server is broken  
   c) Respect `itemsPerPage` and iterate pages until `totalResults` are retrieved  
   d) Switch to DELETE then re-run

---

## 🔗 Navigation
👉 Back: [3.05 Filtering](3.05-filtering.md)  
👉 Next: [3.07 Attribute Selection](3.07-attribute-selection.md)  

➡️ Next, we’ll explore **Attribute Selection (3.07)** to reduce payloads using `attributes` and `excludedAttributes`.
