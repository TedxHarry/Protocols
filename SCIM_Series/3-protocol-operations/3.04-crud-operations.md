# 🏆 Section 3.04 | Protocol Operations | “CRUD Operations”

---

## 📌 At a glance
CRUD (Create, Read, Update, Delete) operations in SCIM map directly to **HTTP methods**.  
They are the building blocks of SCIM provisioning flows for users and groups.  

---

## 📖 What are CRUD Operations in SCIM?
CRUD operations define how clients (IdPs) manage resources (Users, Groups) on SCIM servers (SaaS apps).  
They ensure consistent provisioning behavior across all compliant systems.  

> **Notes**
- Defined in **RFC 7644**.  
- CRUD = Create (POST), Read (GET), Update (PUT/PATCH), Delete (DELETE).  
- Foundation for lifecycle events: joiner, mover, leaver.  

---

## ❗ Problem before SCIM CRUD
- Every vendor used proprietary APIs with inconsistent verbs.  
- Example: One app used SOAP, another used CSV upload, another used custom REST.  
- This led to **connector sprawl**, high cost, and brittle integrations.  
- SCIM CRUD standardized these operations → one model, many apps.  

---

## 🔑 Key characteristics
- **Create** → `POST /Users` or `POST /Groups`.  
- **Read** → `GET /Users/{id}` or `GET /Groups/{id}`.  
- **Update** → `PUT` (full replace) or `PATCH` (partial update).  
- **Delete** → `DELETE /Users/{id}` (or better → `PATCH active:false`).  
- **Idempotency** → PUT can be retried safely, PATCH cannot.  
- **Filtering support** → `GET /Users?filter=userName eq "jsmith"`.  

---

## 🌍 Why it matters (and how it helps you later)
- CRUD operations are the **core mechanics** of provisioning.  
- Every joiner/mover/leaver event in IAM maps back to CRUD.  
- As an IAM engineer, you’ll troubleshoot CRUD flows daily.  
- Understanding CRUD also prepares you for advanced features like **bulk operations and filtering**.  

---

## 🛠️ Where it’s used (flows + impact)

### Joiner → Create
```
HR → IdP → POST /Users → App Account Created
```

### Mover → Update
```
Role Change → IdP → PATCH /Users → App Attributes Updated
```

### Leaver → Deactivate
```
Termination → IdP → PATCH active:false → App Account Disabled
```

Impact: CRUD ensures **consistency across vendors**, reducing integration costs.  

---

## 🔗 How this links to other concepts
- [3.03 HTTP Methods](3.03-http-methods.md) → CRUD is the structured use of those verbs.  
- [3.05 Filtering](3.05-filtering.md) → Enhances Read by narrowing results.  
- [3.08 Bulk Operations](3.08-bulk-operations.md) → Optimizes multiple CRUD actions at once.  

---

## ⚙️ Technical deep dive

### Example: Create user
```http
POST /Users
Content-Type: application/scim+json

{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
  "userName": "ajones",
  "emails": [{ "value": "ajones@example.com", "primary": true }]
}
```

### Example: Read user by ID
```http
GET /Users/2819c223-7f76-453a-919d-413861904646
Authorization: Bearer <token>
```

### Example: Update user (PATCH)
```http
PATCH /Users/2819c223-7f76-453a-919d-413861904646
Content-Type: application/scim+json

{
  "schemas":["urn:ietf:params:scim:api:messages:2.0:PatchOp"],
  "Operations": [{
    "op": "replace",
    "path": "department",
    "value": "Finance"
  }]
}
```

### Example: Delete user
```http
PATCH /Users/2819c223-7f76-453a-919d-413861904646
Content-Type: application/scim+json

{
  "schemas":["urn:ietf:params:scim:api:messages:2.0:PatchOp"],
  "Operations": [{
    "op": "replace",
    "path": "active",
    "value": false
  }]
}
```

**Key points**:  
- `DELETE` can remove records, but `PATCH active:false` is safer.  
- CRUD examples must always respect the SCIM schema.  
- Audit-friendly flows prefer disabling over hard deletes.  

---

## 🏢 Real-world scenario
A company provisions ServiceNow accounts from Workday.  

- Joiners → `POST /Users` → instant ServiceNow accounts.  
- Movers → `PATCH /Users` → updated department and roles.  
- Leavers → `PATCH active:false` → account disabled, audit trail intact.  

**Impact:** Reduced onboarding from 3 days → under 30 minutes, eliminated ghost accounts.  

---

## ❌ Common pitfalls
- Using PUT for partial updates → wipes attributes not included.  
- Relying on DELETE → loses audit history.  
- Not implementing GET filters → leads to performance issues on large datasets.  
- Assuming PATCH supported everywhere.  
- Forgetting idempotency rules → leads to inconsistent updates.  

---

## ⚠️ Risks & issues

| Risk | Impact | Mitigation |
|------|--------|------------|
| PUT misuse | Overwrites attributes unintentionally | Use PATCH unless full replace needed |
| DELETE misuse | Breaks audit trails | Use PATCH active:false instead |
| Missing filter logic | Large data transfers | Implement filtering in syncs |
| Vendor gaps in PATCH | Updates fail | Check `/ServiceProviderConfig` before deploying |

**Real-world:** A provisioning job accidentally cleared thousands of email addresses because PUT was used instead of PATCH.  

---

## 📝 Mini quiz
1. Which HTTP method is recommended for disabling a user?  
   a) DELETE  
   b) PATCH with `active:false`  
   c) PUT  
   d) GET  

2. Which CRUD action corresponds to `GET /Groups`?  
   a) Create  
   b) Read  
   c) Update  
   d) Delete  

3. Scenario: A sync job sends PUT instead of PATCH, wiping out user phone numbers. What’s the error?  
   a) Wrong filter applied  
   b) Misuse of idempotent method  
   c) PUT used instead of PATCH  
   d) UserName missing  

---

## 🔗 Navigation
👉 Back: [3.03 HTTP Methods](3.03-http-methods.md)  
👉 Next: [3.05 Filtering](3.05-filtering.md)  

➡️ Next, we’ll explore **Filtering (3.05)** to see how SCIM enables powerful search and query capabilities.
