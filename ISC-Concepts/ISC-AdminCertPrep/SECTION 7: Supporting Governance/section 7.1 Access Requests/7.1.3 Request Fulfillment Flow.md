### 7.1.3: Request Fulfillment Flow

### Overview
Request fulfillment is the end-to-end process from approval through actual access delivery. Understanding the complete fulfillment flow—including approval chains, provisioning plan creation, execution methods, and verification—is essential for both administrators and the certification exam.

**What you'll learn:**
- Approval workflow mechanics
- Sequential vs. parallel approvals
- Provisioning plan structure
- Fulfillment methods (direct, ticketing, file-based)
- Verification and confirmation
- Fulfillment troubleshooting
- Performance optimization

---

### Approval Workflow Execution

#### Approval Chain Types

**Sequential (Serial) Approvals**
```
Definition: Approvals occur one after another in strict order
Characteristic: Each level must complete before next begins

Flow:
Request Submitted
  ↓
Level 1: Manager Approval
  ↓ (only if Level 1 approves)
Level 2: Role Owner Approval
  ↓ (only if Level 2 approves)
Level 3: Security Team Approval
  ↓ (only if Level 3 approves)
Approved → Provisioning

Rejection at ANY level = entire request denied
```

**Sequential approval example:**
```
Request: Domain Admin role
Why sequential: Increasing privilege escalation

Level 1 - Manager (approve business need)
  Decision: Approve
  Time: 2 hours
  
Level 2 - IT Manager (approve technical need)
  Decision: Approve
  Time: 4 hours
  
Level 3 - Security Officer (approve risk)
  Decision: Approve
  Time: 1 day
  
Total approval time: 1 day, 6 hours
All 3 levels required in order
```

**Sequential characteristics:**
- ✓ Clear approval hierarchy
- ✓ Each approver has full context from previous approvals
- ✓ Appropriate for escalating privileges
- ✗ Longer total approval time
- ✗ Single denial stops entire chain
- ✗ Bottleneck if one approver delayed

---

**Parallel Approvals**
```
Definition: Multiple approvers review simultaneously
Characteristic: All approvers notified at same time

Flow:
Request Submitted
  ↓
  ├─→ Manager Approval ─┐
  ├─→ Owner Approval  ──┼→ All must approve
  └─→ Security Approval ─┘
  ↓
Approved → Provisioning

ALL parallel approvers must approve
```

**Parallel approval example:**
```
Request: Sales Tools role (includes CRM, BI, Email Lists)
Why parallel: Different stakeholders for different components

Notified simultaneously:
├─ CRM Owner → Approves Salesforce access (2 hours)
├─ BI Owner → Approves Tableau access (3 hours)
└─ Marketing Owner → Approves email list access (1 hour)

Total approval time: 3 hours (longest individual)
All 3 must approve, but can approve independently
```

**Parallel characteristics:**
- ✓ Faster total approval time
- ✓ Multiple stakeholders review concurrently
- ✓ Appropriate for multi-component access
- ✗ All must still approve (any denial fails request)
- ✗ Coordination challenges if changes needed
- ✗ Potential for conflicting feedback

---

**Hybrid Approvals (Sequential + Parallel)**
```
Most common in enterprise environments

Flow:
Request Submitted
  ↓
Level 1 (Sequential): Manager Approval
  ↓
Level 2 (Parallel): Multiple owners approve simultaneously
  ├─→ App Owner 1 ─┐
  ├─→ App Owner 2 ─┼→ All must approve
  └─→ App Owner 3 ─┘
  ↓
Level 3 (Sequential): Security Review
  ↓
Approved → Provisioning
```

**Hybrid approval example:**
```
Request: Engineering Manager role

Level 1 (Sequential): Manager approval
  Manager: "Does this person need manager-level access?"
  Decision: Approve
  Time: 4 hours

Level 2 (Parallel): Application owners
  ├─ JIRA Owner: Approve project admin rights (2 hours)
  ├─ GitHub Owner: Approve org admin rights (1 hour)
  └─ AWS Owner: Approve IAM admin rights (3 hours)
  All must approve
  Parallel duration: 3 hours (longest)

Level 3 (Sequential): Security team
  Security: "Risk assessment acceptable?"
  Decision: Approve
  Time: 1 day

Total time: 1 day, 7 hours
Balances hierarchy with efficiency
```

---

#### Approval Configuration

**Approval scheme definition:**

**Configuration elements:**
```json
{
  "approvalScheme": "MANAGER_OWNER",
  "approvalMode": "SEQUENTIAL",
  "levels": [
    {
      "levelNumber": 1,
      "approverType": "MANAGER",
      "required": true,
      "timeout": "48h",
      "fallbackApprover": "fallback.admin"
    },
    {
      "levelNumber": 2,
      "approverType": "OWNER",
      "required": true,
      "timeout": "72h",
      "fallbackApprover": "owner.backup"
    }
  ]
}
```

**Common approval schemes:**

| Scheme | Approvers | Mode | Use Case |
|--------|-----------|------|----------|
| MANAGER | Manager only | N/A | Low-risk access |
| OWNER | Role/AP owner only | N/A | Standard access |
| MANAGER_OWNER | Manager, then Owner | Sequential | Moderate-risk |
| GOVERNANCE_GROUP | Designated group | Parallel (within group) | High-risk access |
| WORKFLOW | Custom logic | Configurable | Complex scenarios |

---

#### Approver Resolution

**How ISC determines WHO approves:**

**1. MANAGER approval:**
```
Lookup process:
1. Get requester's identity
2. Read manager attribute
3. Verify manager is active identity
4. If no manager → Use fallback approver
5. Create work item for manager

Example:
Requester: john.smith
Manager attribute: "manager.name"
Value: "mike.johnson"
Work item created for: mike.johnson
```

**2. OWNER approval:**
```
Lookup process:
1. Get requested item (role/access profile)
2. Read owner field
3. Verify owner is active identity
4. If no owner → Use fallback approver
5. Create work item for owner

Example:
Requested: "VPN Access" role
Role owner: "network.admin"
Work item created for: network.admin
```

**3. GOVERNANCE_GROUP approval:**
```
Lookup process:
1. Get governance group members
2. Create single work item
3. Distribute to all members
4. First to approve = approval for group
5. Any can approve/deny

Example:
Governance group: "Security Team"
Members: [sec.admin1, sec.admin2, sec.admin3]
Work item sent to: All 3 members
Any one can complete the approval
```

**4. WORKFLOW approval:**
```
Lookup process:
1. Execute workflow
2. Workflow determines approver(s)
3. Can implement complex logic
4. May return multiple approvers
5. Can dynamically change based on request

Example:
Workflow: "Risk-Based Approval"
Logic:
  If riskScore > 75:
    Require CISO approval
  Else if riskScore > 50:
    Require Security Manager approval
  Else:
    Require standard Manager approval
Result: Dynamic approver based on risk
```

---

#### Approval Decision Processing

**Decision options:**

**1. Approve**
```
Approver action: Click "Approve" button
Optional: Add approval comments
System processing:
  1. Record approval decision
  2. Timestamp and approver captured
  3. Update work item status to "Approved"
  4. If more levels → Notify next approver
  5. If final level → Create provisioning plan
  6. Notify requester of approval
```

**2. Deny (Reject)**
```
Approver action: Click "Deny" button
Required: Denial reason
System processing:
  1. Record denial decision
  2. Timestamp and approver captured
  3. Update work item status to "Denied"
  4. Cancel entire request (all levels)
  5. No provisioning occurs
  6. Notify requester with reason
  7. Close request permanently
```

**3. Forward/Reassign**
```
Approver action: Click "Forward" button
Required: Target approver, reason
System processing:
  1. Remove original approver
  2. Assign to new approver
  3. Notify new approver
  4. Notify requester of reassignment
  5. Reset timer for new approver
  6. Preserve approval level
```

**4. Request Information**
```
Approver action: Click "Request Info" button
Required: Question/clarification needed
System processing:
  1. Pause approval timer
  2. Notify requester
  3. Status: "Information Requested"
  4. Await requester response
  5. Resume when response received
  6. Notify approver of response
```

**5. Timeout (No Action)**
```
Automatic action: Timer expires
Configurable behavior:
  Option A: Auto-deny (most secure)
    → Request denied
    → Requester notified
    
  Option B: Escalate to manager
    → Forward to approver's manager
    → New timer starts
    
  Option C: Forward to fallback
    → Forward to designated fallback approver
    → New timer starts
    
  Option D: Auto-approve (rare, risky)
    → Request auto-approved
    → Audit record created
```

---

### Provisioning Plan Creation

#### Provisioning Plan Components

**Plan structure:**
```json
{
  "provisioningPlan": {
    "planId": "PP-2024-00123",
    "requestId": "AR-2024-01234",
    "identity": {
      "id": "2c91808a7624751a01762f19d665344d",
      "name": "jane.doe",
      "displayName": "Jane Doe"
    },
    "accountRequests": [
      {
        "application": "Active Directory",
        "operation": "Modify",
        "nativeIdentity": "CN=Jane Doe,OU=Users,DC=corp,DC=local",
        "attributeRequests": [
          {
            "name": "memberOf",
            "operation": "Add",
            "value": "CN=VPN-Users,OU=Groups,DC=corp,DC=local"
          },
          {
            "name": "memberOf",
            "operation": "Add",
            "value": "CN=Remote-Desktop-Users,OU=Groups,DC=corp,DC=local"
          }
        ]
      },
      {
        "application": "Salesforce",
        "operation": "Modify",
        "nativeIdentity": "jane.doe@company.com",
        "attributeRequests": [
          {
            "name": "PermissionSetAssignments",
            "operation": "Add",
            "value": "Sales_User"
          }
        ]
      }
    ],
    "provisioningTargets": [
      {
        "applicationId": "2c91808b...",
        "applicationName": "Active Directory",
        "accountId": "2c91808c...",
        "accountName": "jdoe"
      },
      {
        "applicationId": "2c91808d...",
        "applicationName": "Salesforce",
        "accountId": "2c91808e...",
        "accountName": "jane.doe@company.com"
      }
    ],
    "created": "2024-02-15T14:35:00Z",
    "status": "Pending"
  }
}
```

---

#### Plan Creation Logic

**Step-by-step creation:**

**Step 1: Identify target identity**
```
Input: Requested for identity ID
Lookup: Identity object
Retrieve: All correlated accounts
Result: Know who is receiving access
```

**Step 2: Resolve requested items**
```
For each requested item:
  If Role:
    1. Get all access profiles in role
    2. For each access profile:
       a. Get all entitlements
       b. Determine target source
       c. Add to provisioning plan
       
  If Access Profile:
    1. Get all entitlements in profile
    2. Determine target source
    3. Add to provisioning plan
    
  If Entitlement:
    1. Get entitlement details
    2. Determine target source
    3. Add to provisioning plan
```

**Step 3: Map to accounts**
```
For each entitlement to provision:
  1. Determine source application
  2. Find correlated account for identity on that source
  3. If account exists:
     → Operation = Modify
     → Add entitlement to existing account
  4. If account doesn't exist:
     → Operation = Create
     → Create account first, then add entitlement
  5. Build attribute requests
```

**Step 4: Optimize operations**
```
Consolidation:
  - Combine multiple entitlements to same account
  - Single Modify operation with multiple attributes
  - Reduces API calls to target system
  
Example:
Instead of:
  - Modify account: Add group1
  - Modify account: Add group2
  - Modify account: Add group3

Optimize to:
  - Modify account: Add groups [group1, group2, group3]
```

**Step 5: Create plan record**
```
Generate plan object:
  - Unique plan ID
  - Link to request ID
  - All account requests
  - All attribute requests
  - Provisioning targets
  - Status: Pending
  - Creation timestamp
```

---

#### Example Plan Creation

**Scenario:**
```
Request: Jane Doe requests "VPN Access" role

Role "VPN Access" contains:
  Access Profile: "VPN Users"
    ├─ Entitlement: AD Group "VPN-Users"
    └─ Entitlement: AD Group "Remote-Desktop-Users"
  Access Profile: "Citrix Access"
    └─ Entitlement: Citrix Group "Remote-Workers"

Jane's accounts:
  - Active Directory: jdoe (exists)
  - Citrix: jane.doe (exists)
```

**Plan created:**
```json
{
  "accountRequests": [
    {
      "application": "Active Directory",
      "operation": "Modify",
      "nativeIdentity": "jdoe",
      "attributeRequests": [
        {
          "name": "memberOf",
          "operation": "Add",
          "value": "VPN-Users"
        },
        {
          "name": "memberOf",
          "operation": "Add",
          "value": "Remote-Desktop-Users"
        }
      ]
    },
    {
      "application": "Citrix",
      "operation": "Modify",
      "nativeIdentity": "jane.doe",
      "attributeRequests": [
        {
          "name": "groupMembership",
          "operation": "Add",
          "value": "Remote-Workers"
        }
      ]
    }
  ]
}
```

**Plan interpretation:**
- 2 target systems (AD and Citrix)
- 2 Modify operations (both accounts exist)
- 3 total entitlements to grant
- Optimized: AD changes in single operation

---

### Provisioning Execution

#### Execution Methods

**Method 1: Direct Provisioning (Real-Time)**
```
Description: ISC directly connects to target system
Connection: API, LDAP, JDBC, Web Services
Execution: Real-time, immediate
Verification: Immediate confirmation

Process:
1. Read provisioning plan
2. Establish connection to target
3. Execute provisioning commands
4. Verify success
5. Update plan status
6. Disconnect

Example (Active Directory):
Command: Add-ADGroupMember
Parameters: {
  Identity: "VPN-Users",
  Members: "jdoe"
}
Execution: Immediate
Verification: Get-ADGroupMember confirms
Duration: Seconds
```

**Method 1 characteristics:**
- ✓ Fastest fulfillment
- ✓ Immediate verification
- ✓ Real-time status updates
- ✓ Automated rollback on failure
- ✗ Requires direct connectivity
- ✗ Requires API/connector support
- ✗ May require privileged credentials

**Common direct provisioning targets:**
- Active Directory (LDAP)
- Azure AD / Entra ID (Graph API)
- Salesforce (REST API)
- ServiceNow (REST API)
- Workday (Web Services)
- SAP (RFC/Web Services)
- Database applications (JDBC)

---

**Method 2: Ticketing Integration**
```
Description: ISC creates ticket in external system
Systems: ServiceNow, JIRA, Remedy
Execution: Manual fulfillment by application team
Verification: Ticket closure

Process:
1. Read provisioning plan
2. Generate ticket in ticketing system
3. Populate ticket with request details
4. Assign to application team queue
5. Team manually provisions access
6. Team closes ticket when complete
7. ISC receives closure notification
8. ISC updates request status

Example (ServiceNow):
Ticket created:
  Short Description: "Grant VPN Access to Jane Doe"
  Description: "User: jane.doe
                Requested: VPN Access role
                Entitlements: VPN-Users, Remote-Desktop-Users
                Request ID: AR-2024-01234
                Approved by: Manager, Owner
                Priority: Normal"
  Assignment Group: "Network Team"
  
Manual steps by team:
1. Receive ticket
2. Validate approval
3. Add user to AD groups
4. Test user access
5. Close ticket with notes
6. ISC marks request complete
```

**Method 2 characteristics:**
- ✓ Works for any system (even manual processes)
- ✓ Human verification possible
- ✓ Handles complex scenarios
- ✓ Audit trail in ticketing system
- ✗ Slower (hours to days)
- ✗ Manual effort required
- ✗ Potential for errors
- ✗ Delayed confirmation

**Common ticketing scenarios:**
- Legacy applications (no API)
- Physical access (badge systems)
- Manual approval processes
- Complex application-specific logic
- High-risk access requiring validation
- Applications undergoing migration

---

**Method 3: File-Based Provisioning**
```
Description: ISC generates file with changes
Format: CSV, XML, fixed-width, custom
Delivery: SFTP, shared drive, email
Execution: Batch processing by target
Verification: Response file or next aggregation

Process:
1. Read provisioning plan
2. Generate formatted file
3. Include: Identity, operation, entitlements
4. Transfer file to designated location
5. Target system processes file (batch)
6. Target generates response file (optional)
7. ISC imports response
8. Update request status

Example (Mainframe RACF):
Generated file (provisioning_20240215.txt):
ADD USER=JDOE GROUP=VPNUSERS
ADD USER=JDOE GROUP=REMOTEUSERS
PERMIT CITRIX ACCESS(READ) ID(JDOE)

File transfer: SFTP to mainframe
Processing: Nightly batch job
Confirmation: Response file or next day aggregation
```

**Method 3 characteristics:**
- ✓ Works for batch-oriented systems
- ✓ Handles large volumes efficiently
- ✓ Lower connection overhead
- ✓ Scheduled processing windows
- ✗ Delayed execution (batch schedule)
- ✗ Delayed confirmation
- ✗ Limited error handling
- ✗ File format dependencies

**Common file-based targets:**
- Mainframe systems (RACF, ACF2, Top Secret)
- Legacy HR systems
- Custom in-house applications
- Batch-oriented databases
- File-based security systems

---

#### Execution Process Details

**Direct provisioning workflow:**

**Phase 1: Pre-execution validation**
```
Checks before executing:
1. Target system reachable?
   → Ping/connectivity test
   
2. Credentials valid?
   → Test authentication
   
3. Account exists?
   → Query target for account
   
4. Required attributes present?
   → Validate plan completeness
   
If any check fails:
→ Mark provisioning failed
→ Capture error details
→ Notify requester
→ Admin can retry
```

**Phase 2: Command execution**
```
For each account request:
  For each attribute request:
    1. Build target command
    2. Execute command
    3. Capture result
    4. If success → Continue
    5. If failure → Log error, continue or stop
```

**Phase 3: Verification**
```
After execution:
1. Query target system
2. Confirm changes applied
3. Compare expected vs. actual
4. If match → Success
5. If mismatch → Investigate

Example verification:
Expected: User in VPN-Users group
Query: Get-ADGroupMember -Identity "VPN-Users"
Result: [... jdoe ...]
Verification: ✓ Success
```

**Phase 4: Status update**
```
Update provisioning plan:
  Status: Completed / Partially Completed / Failed
  Completion timestamp
  Success/failure details per operation
  Error messages if applicable

Update access request:
  Status: Completed / Partially Completed / Failed
  Link to provisioning plan
  Notify requester
```

---

### Verification and Confirmation

#### Verification Methods

**1. Real-time verification (Direct provisioning)**
```
Immediate after provisioning:
1. Query target system
2. Confirm entitlement granted
3. Update request status immediately

Example:
Action: Added user to AD group
Verification: LDAP query confirms membership
Status: Confirmed within seconds
```

**2. Aggregation-based verification**
```
Next scheduled aggregation:
1. Aggregate accounts from source
2. Entitlements discovered
3. Correlated to identity
4. Request marked complete if found

Example:
Action: Manually added to mainframe group
Verification: Next nightly aggregation
Discovery: Group membership found
Status: Confirmed next business day
```

**3. Ticketing confirmation**
```
Ticket closure triggers confirmation:
1. Application team closes ticket
2. Ticket status change detected
3. ISC marks request complete
4. Assumes provisioning successful

Example:
Ticket #INC123456 closed
Closure notes: "Added user to VPN group, tested access"
ISC action: Mark AR-2024-01234 complete
```

---

#### Confirmation Notification

**Requester notification:**
```
Email sent when provisioning completes:

Subject: Access Request Completed - AR-2024-01234

Your access request has been completed successfully.

Request Details:
- Request ID: AR-2024-01234
- Requested: VPN Access (Role)
- Status: Completed
- Completed: February 15, 2024 at 3:45 PM

Access Granted:
✓ VPN Users (Active Directory)
✓ Remote Desktop Users (Active Directory)
✓ Remote Workers (Citrix)

You can now access:
- Corporate VPN
- Remote desktop resources
- Citrix virtual desktops

Getting Started:
1. Disconnect and reconnect VPN
2. Wait 15 minutes for replication
3. Try accessing remote resources
4. Contact IT Support if issues

Questions? Reply to this email or call x5555.
```

**In-app notification:**
```
Dashboard notification badge:
"Your access request AR-2024-01234 is complete"

Click → Shows:
- Full request details
- What was granted
- How to use new access
- Support contact if issues
```

---

### Common Fulfillment Issues

#### Issue 1: Account Not Found

**Problem:**
```
Provisioning plan: Modify account "jdoe" on Active Directory
Error: "Account 'jdoe' not found"
```

**Root causes:**
```
1. Account doesn't exist on target
2. Account name mismatch (john.doe vs jdoe)
3. Account deleted after request submitted
4. Correlation is wrong
```

**Resolution:**
```
Option A: Create account first
  1. Change operation from Modify to Create
  2. Execute account creation
  3. Then grant entitlements
  
Option B: Fix correlation
  1. Find correct account name
  2. Update correlation config
  3. Re-correlate identity
  4. Retry provisioning
  
Option C: Manual provision
  1. Create account manually
  2. Run aggregation
  3. Retry provisioning
```

---

#### Issue 2: Permission Denied

**Problem:**
```
Provisioning command: Add-ADGroupMember
Error: "Insufficient permissions"
```

**Root causes:**
```
1. ISC service account lacks permissions
2. Group is protected/privileged
3. Target system security policy blocks
4. Delegation rights not configured
```

**Resolution:**
```
1. Grant required permissions:
   - Add ISC service account to appropriate admin groups
   - Grant delegation rights in AD
   
2. Update group permissions:
   - Modify group's security settings
   - Add ISC service account to ACL
   
3. Use elevated credentials:
   - Configure separate privileged account
   - Use for sensitive provisioning only
```

---

#### Issue 3: Provisioning Timeout

**Problem:**
```
Provisioning status: In Progress (stuck)
Duration: 30+ minutes
Expected: Complete in <5 minutes
```

**Root causes:**
```
1. Target system slow/overloaded
2. Network connectivity issues
3. Large batch of operations
4. API rate limiting
```

**Resolution:**
```
1. Check target system health
2. Verify network connectivity
3. Review API logs for rate limits
4. Retry provisioning operation
5. If repeated: Increase timeout threshold
```

---

#### Issue 4: Partial Provisioning

**Problem:**
```
Request for 3 entitlements
Result: 2 granted, 1 failed
Status: Partially Completed
```

**Root causes:**
```
1. One entitlement doesn't exist on target
2. One target system unavailable
3. Permission denied for one operation
4. One entitlement already granted (duplicate)
```

**Resolution:**
```
1. Review provisioning plan details
2. Identify which operation(s) failed
3. Check error message for failed items
4. Address root cause:
   - Missing entitlement → Refresh entitlements
   - System down → Wait and retry
   - Permission → Grant rights
   - Duplicate → Mark as complete
5. Manually provision failed items if needed
```

---

### Performance Optimization

#### Optimization Strategies

**1. Batch similar operations**
```
Instead of:
Request 1: VPN Access → Provision
Request 2: Email Access → Provision
Request 3: File Share Access → Provision

Better:
Batch Request: VPN + Email + File Share → Single provisioning cycle
Result: Fewer API calls, faster overall
```

**2. Optimize approval chains**
```
Poor: 5 sequential levels
  Manager → Owner → App Owner → Security → Compliance
  Total time: Sum of all levels (days)

Better: 2-3 levels with parallel where appropriate
  Level 1: Manager
  Level 2: Owner + App Owner + Security (parallel)
  Total time: Manager time + longest parallel time (hours)
```

**3. Use provisioning policies**
```
Configure:
- Retry attempts: 3
- Retry delay: 30 seconds
- Timeout: 5 minutes
- Batch size: 100 operations

Results:
- Automatic retry on transient failures
- Reasonable timeouts prevent hanging
- Batch processing for efficiency
```

**4. Parallel provisioning**
```
Request grants access on 3 systems:
  System A, System B, System C

Sequential: A → B → C (15 minutes total)
Parallel: A + B + C simultaneously (5 minutes)

Configure parallel provisioning for independent systems
```

**5. Pre-provisioning validation**
```
Before provisioning:
1. Verify all accounts exist
2. Verify all entitlements exist
3. Check permissions
4. Test connectivity

Result: Catch issues early, avoid failed provisioning
```

---

### Exam Tips

**Key concepts tested:**
✅ Sequential vs. parallel approval differences
✅ Provisioning plan structure and components
✅ Direct vs. ticketing vs. file-based provisioning
✅ Approver resolution logic
✅ Provisioning verification methods
✅ Common fulfillment errors and resolutions
✅ Hybrid approval workflows

**Common exam scenarios:**
- Design approval workflow for given requirements
- Interpret provisioning plan JSON
- Choose appropriate provisioning method
- Troubleshoot "account not found" error
- Calculate total approval time (sequential vs. parallel)
- Identify why provisioning failed

**Remember:**
- Sequential = one after another (slower, hierarchical)
- Parallel = simultaneous (faster, all must still approve)
- Hybrid = combination of both (most common)
- Provisioning plan created AFTER final approval
- Direct provisioning = real-time, fastest
- Ticketing = manual, slower but flexible
- Verification confirms access actually granted
- Partial completion = some succeeded, some failed

---

### Key Takeaways

✅ **Approval types** - Sequential (hierarchical), Parallel (simultaneous), Hybrid (combination)

✅ **Provisioning plan** - Created after final approval, before execution

✅ **Three fulfillment methods** - Direct (API), Ticketing (manual), File-based (batch)

✅ **Approver resolution** - MANAGER (lookup), OWNER (item owner), GOVERNANCE_GROUP (any member)

✅ **Plan structure** - Identity + Account Requests + Attribute Requests + Targets

✅ **Verification** - Real-time (direct), Aggregation (scheduled), Ticketing (closure)

✅ **Common errors** - Account not found, Permission denied, Timeout, Partial provisioning

✅ **Optimization** - Batch operations, Parallel where possible, Pre-validation

---

**Next Section:** 7.2 - Access Certifications - We'll cover certification campaigns, reviewer responsibilities, certification types, and compliance reporting.
