![Cover](./covers/2.12-error-model.png)
# ğŸ† Section 2.12 | SCIM in Practice | â€œSCIM Error Model (and Why It Matters)â€

Every SCIM integration eventually runs into **errors**.  
If you donâ€™t understand how SCIM represents errors, debugging becomes frustrating, and integrations break silently.  

---

## ğŸ“– Why the Error Model Matters  

- **Troubleshooting** â†’ clear errors speed up debugging.  
- **Resilience** â†’ integrations must handle partial failures gracefully.  
- **Compliance** â†’ error codes help prove proper handling of bad requests.  
- **Security** â†’ some errors reveal too much, others too little â€” balance is key.  

---

## 1ï¸âƒ£ Structure of a SCIM Error Response  

Errors follow the **SCIM Error Response Schema**.  

**Example:**  

```json
{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "400",
  "scimType": "invalidValue",
  "detail": "The 'userName' attribute is required."
}
```

### Fields Explained  
- `schemas` â†’ always includes the SCIM error URN.  
- `status` â†’ HTTP status code (string).  
- `scimType` â†’ SCIM-specific error type (optional).  
- `detail` â†’ human-readable explanation.  

---

## 2ï¸âƒ£ Common SCIM Error Types  

- **invalidFilter** â†’ filter syntax not valid.  
- **tooMany** â†’ request returns more results than supported.  
- **uniqueness** â†’ attribute must be unique (e.g., `userName`).  
- **mutability** â†’ attribute is read-only or immutable.  
- **invalidValue** â†’ bad data type or value.  
- **invalidSyntax** â†’ malformed request payload.  
- **notFound** â†’ resource not found.  
- **temporarilyUnavailable** â†’ server busy or down.  

---

## 3ï¸âƒ£ Hands-On Lab: Testing Errors  

### Invalid Filter Example  

```http
GET /Users?filter=unknownAttr eq "test"
```

**Expected Response**  

```json
{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "400",
  "scimType": "invalidFilter",
  "detail": "Attribute 'unknownAttr' not supported."
}
```

---

### Uniqueness Violation  

```http
POST /Users
Content-Type: application/scim+json

{
  "userName": "jane.doe",
  "displayName": "Jane Doe"
}
```

(If `jane.doe` already exists)  

```json
{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "409",
  "scimType": "uniqueness",
  "detail": "A user with userName 'jane.doe' already exists."
}
```

---

### Mutability Error  

```http
PATCH /Users/12345
Content-Type: application/scim+json

{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:PatchOp"],
  "Operations": [
    { "op": "replace", "path": "id", "value": "99999" }
  ]
}
```

```json
{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "400",
  "scimType": "mutability",
  "detail": "Attribute 'id' is read-only."
}
```

---

## âš ï¸ Common Pitfalls (and Impact)  

- âŒ **Ignoring `scimType`** â†’ lose context about what failed.  
- âŒ **Not handling partial failures in Bulk** â†’ one bad record breaks sync.  
- âŒ **Overexposed error details** â†’ risk of leaking system info.  
- âŒ **Vendor inconsistency** â†’ some return plain HTTP errors without SCIM schema.  

---

## âœ… Best Practices  

- Always parse both `status` and `scimType`.  
- Log `detail` for debugging but sanitize before exposing externally.  
- Build retry logic for `temporarilyUnavailable`.  
- Expect differences across vendors â€” some ignore SCIM error schema.  
- Validate requests before sending to minimize avoidable errors.  

---

## ğŸ¢ Real-World Scenarios  

- **Sync Job** â†’ fails due to uniqueness conflicts â†’ SCIM error response explains the cause.  
- **IAM Audit** â†’ error logs show invalid filters used by a misconfigured connector.  
- **User Deprovisioning** â†’ request fails because the user no longer exists â†’ handled gracefully with `404 notFound`.  

---

## ğŸ“ Self-Check  

1ï¸âƒ£ What are the key fields in a SCIM error response?  
2ï¸âƒ£ How does `scimType` add value beyond the HTTP status code?  
3ï¸âƒ£ Give one example of an error type you might encounter during user creation.  
4ï¸âƒ£ Why is it risky to expose raw SCIM error details to end users?  

---

## ğŸ¯ Final Takeaway  

SCIMâ€™s error model is simple but powerful.  
- Errors follow a standard schema with `status`, `scimType`, and `detail`.  
- Understanding errors makes troubleshooting faster and integrations more resilient.  
- Always expect vendor differences and handle them gracefully.  

ğŸ’¡ Robust error handling separates a fragile SCIM integration from a production-ready one.  

---

## ğŸ”— Navigation  

ğŸ‘‰ Back: [2.11 Deprovisioning & Lifecycle Management](2.11-deprovisioning.md)  
ğŸ‘‰ Next: [2.13 Dealing with Partial Vendor Implementations](2.13-partial-vendor-support.md)  
