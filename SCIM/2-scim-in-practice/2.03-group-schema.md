![Cover](./covers/2.03-group-schema.png)
# ğŸ† Section 2.03 | SCIM in Practice | â€œGroup Schema Detailsâ€

Groups are how SCIM represents **collections of users** (and sometimes collections of groups).  
They are the foundation of scalable access control: instead of assigning permissions user by user, you grant them to a Group. Mastering the Group resource helps you manage application access, role assignment, and team-based permissions with confidence.  

This guide is **vendor neutral** and aligns with **RFC 7643** and **RFC 7644**.  

---

## ğŸ“– What is a SCIM Group?  

A **Group** is a resource that holds **references to members**.  

- Members are usually Users.  
- Some implementations also support **nested groups** (groups inside groups).  
- Groups let you **manage access at scale**, without handling permissions one person at a time.  

**Schema URN** (always required):  

```text
urn:ietf:params:scim:schemas:core:2.0:Group
```

---

## ğŸ§© Core Attributes  

ğŸ‘‰ **Mandatory attributes when creating a Group:**  
### `schemas`  
- Always includes the Group schema URN above.

### `id`  
- Server-assigned identifier for the group.  
- Read-only for clients.  
- Stable for the life of the resource.  

### `displayName`  
- Human-readable name of the group.  
- Required for create operations.  
- Must be unique and clear within the tenant.  

### `members`  
- An array of **references** to Users or Groups.  
- Each item can contain:  
  - `value` â†’ the referenced resourceâ€™s `id` (**required**)  
  - `display` â†’ optional, human-readable label  
  - `$ref` â†’ sometimes included, full URL of the resource  

Example member reference:  

```json
{ "value": "2819c223-7f76-453a-919d-413861904646", "display": "Jane Doe" }
```

âš ï¸ Remember: `value` links the membership. `display` is just decoration.  

### `meta`  
- Metadata about the resource (creation time, last modification, location).  
- Crucial for auditing and detecting changes.  

---

## ğŸ§ª JSON Examples  

### 1) Minimal Group (no members yet)  

```json
{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:Group"],
  "displayName": "Engineering"
}
```

### 2) Group with multiple users  

```json
{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:Group"],
  "displayName": "Engineering",
  "members": [
    { "value": "2819c223-7f76-453a-919d-413861904646", "display": "Jane Doe" },
    { "value": "8742ffde-df2c-4c1e-a8ab-3f7e6a2b8e21", "display": "Alex Kim" }
  ]
}
```

### 3) Nested group example  

Not all providers support nested groups. If supported, `members` may include a Group id.  

```json
{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:Group"],
  "displayName": "Platform Leadership",
  "members": [
    { "value": "a1a1a1a1-1111-2222-3333-444444444444", "display": "Engineering" }, 
    { "value": "b2b2b2b2-2222-3333-4444-555555555555", "display": "Product" }
  ]
}
```

âš ï¸ Nested groups can create complexity: sync delays, loops, or authorization issues. Always confirm if your SP supports them.  

### 4) Add and remove members with PATCH  

Always use `PATCH` for incremental membership updates.  

```http
PATCH /Groups/a1a1a1a1-1111-2222-3333-444444444444
Content-Type: application/scim+json

{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:PatchOp"],
  "Operations": [
    {
      "op": "add",
      "path": "members",
      "value": [
        { "value": "2819c223-7f76-453a-919d-413861904646" }
      ]
    },
    {
      "op": "remove",
      "path": "members[value eq \"8742ffde-df2c-4c1e-a8ab-3f7e6a2b8e21\"]"
    }
  ]
}
```

ğŸ‘‰ Using `PUT` replaces the entire list â€” dangerous for large groups. PATCH is safer and more efficient.  

---

## ğŸ”„ Membership Synchronization Logic  

### Big picture  

```
IdP source of truth  â†’  SCIM /Groups  â†’  Service Provider
```

- **Push model**: IdP sends group creates and membership changes.  
- **Pull/reconcile**: IdP reads `/Groups` and `/Groups/{id}` to detect or fix drift.  
- **Incremental updates**: Prefer PATCH for specific adds/removes.  

### ASCII walkthrough of a typical sync  

```
[HR/Directory] --new hire--> [IdP]
[IdP] --add user to role--> [IdP Group]
[IdP] --PATCH add member--> [SP /Groups/{id}]
[SP] --updates entitlements--> [Application Access]
```

### Handling large groups  

- Break updates into **batches** if SP has request limits.  
- Use `/Bulk` only if supported and necessary.  
- For very large groups, use **incremental updates** (PATCH) instead of full list replacements.  
- Check if the SP has **maximum group size limits** (some cap at 1,000 or 5,000).  

---

## âœ… Best Practices  

- Treat `displayName` as the **canonical label** for people and automation.  
- Keep group names stable, human-readable, and unique. Avoid opaque IDs as names.  
- Always include `schemas` when creating Groups.  
- Use **PATCH** for membership changes (safe, incremental).  
- Document whether nested groups are supported. Flatten memberships if they are not.  
- Always use `id` values for member references (avoid relying only on display names).  

---

## âš ï¸ Common Pitfalls (and Impact)  

- âŒ **Missing `displayName`** â†’ many SPs reject the request.  
- âŒ **Missing `schemas`** â†’ request fails immediately.  
- âŒ **Duplicate or invalid member IDs** â†’ PATCH fails; validate before sending.  
- âŒ **Using PUT for membership changes** â†’ accidentally wipes entire member list.  
- âŒ **Assuming nested groups work** â†’ may not be supported; check `/ServiceProviderConfig`.  
- âŒ **Circular references in nested groups** â†’ causes sync loops or broken authorization.  
- âŒ **Huge one-shot updates** â†’ exceeds request limits, causing failures. Use batching or `/Bulk`.  

---

## ğŸ“ Self-Check  

1ï¸âƒ£ Which attributes are mandatory when creating a Group?  
2ï¸âƒ£ Why is `PATCH` preferred over `PUT` for updating memberships?  
3ï¸âƒ£ What risks come with nested groups?  
4ï¸âƒ£ How should you handle very large group updates to avoid failures?  

---

## ğŸ¯ Final Takeaway  

Groups in SCIM are **reference lists that connect users to access**.  
- Use clear, stable names.  
- Always include `schemas` and `displayName`.  
- Manage memberships incrementally with PATCH.  
- Verify support for nesting and avoid circular references.  
- Plan for scaling: batch large updates and respect SP limits.  

ğŸ’¡ Clean group design leads to simpler provisioning, fewer sync errors, and more predictable application access.  

---

## ğŸ”— Navigation  

ğŸ‘‰ Back: [2.02 User Schema Details](2.02-user-schema.md)  
ğŸ‘‰ Next: [2.04 Enterprise User Extension](2.04-enterprise-extension.md)  
